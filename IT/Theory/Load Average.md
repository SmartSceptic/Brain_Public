---
sr-due: 2027-05-04
sr-interval: 912
sr-ease: 266
alias: [LA, Cредняя загрузка, CPU Load ]  
---
tag: #N/S/Well  #N/T/Conspect #N/T/Article  #N/T/Public 
2023-01-31 18:11,
[CPU Load: когда начинать волноваться?](https://habr.com/ru/post/216827/) переводом [статьи](http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages) из блога компании Scout.
[Что такое Load Average и какую информацию он несет](https://interface31.ru/tech_it/2016/06/linux-nachinayushhim-chto-takoe-load-average-i-kakuyu-informaciyu-on-neset.html)


---
TLDR: [[Load Average|LA]] это три числа, отображаемые при выполнении команд [[% top]], [[% htop]] и [[% uptime]], предоставляющие быстрый **способ просмотреть средние значения нагрузки**, которые указывают на количество задач (процессов), желающих запуститься. В системах Linux эти цифры включают процессы, желающие работать на процессоре, а также процессы, заблокированные при непрерывном вводе-выводе (обычно дисковый ввод-вывод). Это дает общее представление о загрузке ресурсов (или спросе на них), но **не может быть правильно интерпретировано без других инструментов**.  ^2fbea5

___

`Load average` как правило, отображается в виде трёх значений:
```
load average: 0,35, 0,32, 0,41
```
которые обозначают **экспоненциально взвешенные скользящие средние** (для сглаживания краткосрочных колебаний и выделения основных тенденций или циклов), значения загрузки системы на прогрессивно увеличивающихся временных промежутках (одна, пять и пятнадцать минут) и чем меньше их значения — тем лучше.. В UNIX это среднее значение вычислительной работы, которую выполняет система.
#### Аналогия транспортного потока
Одноядерный процессор похож на дорогу с одной полосой движения. Представьте себе, что Вы управяете движением машин по мосту. Иногда, Ваш мост загружен настолько сильно, что машинам приходится ждать в очереди чтобы проехать по нему. Вы хотите дать людям понять, как долго им придется ждать чтобы перебраться на другую сторону реки. Хорошим способом сделать это будет показать _как много машин ждут в очереди в конкретный момент времени_. Если машин в очереди нет, подъезжающие водители будут знать, что они сразу смогут проехать по мосту. В противном случае, они будут понимать, что придется ждать своей очереди.  
Итак, Управляющий Мостом, какую систему обозначений Вы будете использовать? Как насчет такой:  

-   0.00 означает, что на мосту нет ни одной машины. Фактически, значения от 0.00 до 1.00 означают отсутствие очереди. Подъезжающая машина может воспользоваться мостом без ожидания;
-   1.00 означает, что на мосту находится как раз столько автомобилей, сколько он может вместить. Все еще идет хорошо, но, в случае увеличения потока машин, возможны проблемы;
-   Значения, превышающие 1.00 означают наличие очереди на въезде. Насколько большой? Например, значение 2.00 показывает, что в очереди стоит столько же автомобилей, сколько движется по мосту. 3.00 означает, что мост полностью занят и в очереди ожидает в два раза больше машин, чем он может вместить. И так далее.
![image](https://habrastorage.org/r/w1560/getpro/habr/comment_images/855/58c/307/85558c307ef0ef7d42a581cdaf23614c.png)`load average = 1.00`  
![image](https://habrastorage.org/r/w1560/getpro/habr/post_images/aa4/b1e/f09/aa4b1ef09537358cd5b704b97c9eed30.png)`load average = 0.50`  
![image](https://habrastorage.org/r/w1560/getpro/habr/post_images/6d6/571/488/6d65714888407a28b529d676da392d84.png)`load average = 1.70`  
Вот базовое значение загрузки процессора. «Машины» обрабатываются с использованием промежутков процессорного времени («пересекают мост»), либо ставятся в очередь. В Unix это называется _длина очереди выполнения_: количество всех процессов, выполняемых в данный момент времени, плюс количество процессов, ожидающих в очереди.  
Вам, как управляющему мостом, хотелось бы, чтобы машины-процессы никогда не ждали в очереди. Таким образом, предпочтительно, чтобы загрузки процессора была всегда ниже 1.00. Периодически возможны всплески трафика, когда загрузка будет превышать 1.00, но если она постоянно превышает данное значение — это повод начать волноваться.

#### Принцип расчета нагрузки
Каждому нуждающемуся в вычислениях процессу выделяется некий промежуток времени, который зависит от типа процессора и системы, если говорить о современных процессорах Intel, то это значение обычно составляет 10 мс и называется тиком. Каждый тик процессорное время отдается какому-то одному процессу в порядке очереди, но если процесс имеет повышенный или пониженный приоритет, то он, соответственно получит большее или меньшее количество тиков.

Количество использованных тиков, в первом приближении, и представляет загрузку системы. В Linux для оценки загрузки используется интервал в 500 тиков (5 секунд), при этом учитываются как работающие процессы (использованные тики), так и ожидающие (которым не хватило тика, либо они не смогли его использовать, ожидая завершения иной операции).

Если мы используем все тики за указанный промежуток времени и у нас не будет ожидающих сводного тика процессов, то мы получим загрузку процессора на 100% или **load average (LA)** равное 1.

процессам, ожидающим окончания операций ввода-вывода (диск, сеть и т.п.). Во многих источниках указывается, что такие процессы искажают результат load average и мы можем получить высокие значения LA при отсутствии загрузки процессора. Да, это так. Посмотрим на еще одну схему ниже:

[![linux-load-average-002.png](https://interface31.ru/tech_it/assets_c/2016/08/linux-load-average-002-thumb-450xauto-7524.png)](https://interface31.ru/tech_it/assets_c/2016/08/linux-load-average-002-7524.html)
Как видим, из 9 тиков было использовано только 6, т.е. процессор загружен всего на 67%, но так как три процесса ждут данные от диска, то load average по-прежнему равен 1.
Но учитываение подобных оэидаюзих процессов - не искажает значение LA, потому-что средняя загрузка - это не показатель производительности процессора, не результат бенчмарка, не текущая нагрузка, а отношение числа процессов, которым требуются вычислительные ресурсы системы к имеющимся в наличии ресурсам.
И то, что часть процессов ждут жесткий диск и процессор работает вхолостую, не говорит о том, что система находится в простое, наоборот, она не может обработать нагрузку, правда по другой, не зависящей от процессора причине.
Пользователю ведь все равно по какой причине тормозит сайт или приложение,

Load average показывает отношение имеющихся запросов на вычислительные ресурсы к количеству этих самых ресурсов (тиков). Для одного процессора (одного процессорного ядра) использование всех имеющихся ресурсов обозначает load average = 1. Причем это будет справедливо и для Core i7 и для Pentium I, хотя производительность у этих двух процессоров разная.

##### Обеспечить полную загрузку одного процессорного ядра и load average = 1
```bash
perl -e 'while(1){}'
```

 значение load average корректно отражает загрузку системы даже в тех условиях, когда иные показатели не дают корректного представления о происходящих процессах. Так нагрузка на CPU в 157% явно противоречит здравому смыслу, а вот LA = 4,55, на двухядерной системе вполне реально отражает ситуацию.
 Load average является относительной величиной и от реальной производительности CPU не зависит в тоже время показывая наличие или дефицит вычислительных ресурсов.
Для примера возьмем такое значение:
```
load average: 0.99 0.75 0.35
```
Это говорит о том, что имеет место достаточно кратковременный (около десятка минут) всплеск нагрузки, при этом вычислительных ресурсов пока достаточно.
А вот значение:
```
load average:  0.00 0.36 0.59
```
Говорит о том, что не так давно система испытывала значительные нагрузки в течении довольно продолжительного времени (полчаса-час).
А вот такая картина:
```
 load average:  4.55 4.22 4.18
```
Для четырехядерного процессора означает, что он работает на пределе своих возможностей в течении длительного времени (несколько часов).

#### Практическое применение
-   Практическое правило «Требуется присмотр»: 0.70. Если среднее значение загрузки постоянно превышает 0.70, следует выяснить причину такого поведения системы во избежании проблем в будущем;
-   Практическое правило «Почини это немедленно!»: 1.00. Если средняя загрузка системы превышает 1.00, необходимо срочно найти причину и устранить ее. В противном случае, Вы рискуете быть разбуженным посреди ночи и это точно не будет весело;
-   Практическое правило «Щас же 3 ночи!!! ШОЗАНАХ??!!»: 5.00. Если среднее значение загрузки процессора превышает 5.00, у Вас серьезные проблемы. Сервер может подвисать или работать очень медленно. Скорее всего, это произойдет в худший из возможных моментов. Например, посреди ночи или когда Вы выступаете с докладом на конференции.
-   **«Количество ядер = максимальная загрузка»**. В мультипроцессорных системах загрузка вычисляется относительно количества доступных процессорных ядер. 100% загрузка обозначается числом 1.00 для одноядерной машины, числом 2.00 для двуядерной, 4.00 для четырехъядерной и т.д.
-   «Ядра — они и в Африке ядра». То, как ядра распределены по процессорам — неважно. Два четырехъядерных = четыре двуядерных = восем одноядерных процессоров. Имеет значение лишь общее число ядер.
-   **LA 1** - может превышать 1.00, свидетельствуя о кратковременной пиковой нагрузке на систему.
-   **LA 5** - не должен превышать 1.00, в противном случае налицо явный недостаток вычислительных ресурсов.
-   **LA 15** - максимальное значение 0.7 - 0.8, но в любом случае не выше 1.0, в противном случае вы можете получить в три часа ночи звонок от руководства с вопросом: " А что это с нашим сервером???"
На многоядерной (многопроцессорной) системе значения load average следует откорректировать пропорционально числу ядер.
Узнать их количество яжео в linux системе
```
nproc
```
или
```
cat /proc/cpuinfo | grep "cpu cores"
```


#### исключения
- Не для каждой системы важно иметь запас по производтельности и не допускать значения загрузки выше 0.70 — иногда нам нужно чтобы сервер работал «на всю катушку» и в таких случаях `load average = 1.00` — то, что доктор прописал.
- В некоторых сценариях, для достижения максимального КПД «железа», стоит держать значение `load average` несколько выше 1.00 в ущерб эффективности работы каждого отдельного процесса.
- высокий показатель `load average` может быть вызван большим количеством процессов, выполняющих в данный момент операции чтения/записи. То есть, `load average > 1.00` на одноядерной машине не всегда говорит о том, что в Вашей системе отсутствует запас по загрузке процессора. Требуется более внимательное изучение причин такого показателя.